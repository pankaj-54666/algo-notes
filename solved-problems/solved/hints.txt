
#1: Heap - Top K Pattern, https://leetcode.com/list/e9sr11es/
https://leetcode.com/discuss/interview-question/2069641/The-Only-Lists-You-Need-For-Your-Interview-Preparation


------------------------------------------------------------------------------------------
LC215:Kth Largest Element in an Array
 /*
    Approach1: sort and get k^th element from array. | O(nlogn)

    Approach2: Can you try to use single heap to maintain top-k elements only? | O(nlogk)
        Hint: You can discard any new element that overflows the heap!

    Approach3: Use quickSort property, that left side element are smaller than seleted element & right side element are greator than selected element. | avg:O(n), worst:O(n^2)
        -implementation TO-DO:

    Approach4: use simple counting sort, to count all element in the range(you can use map also). Then cound element from left to right, at the point count is k, that element is the answer. | O(n+m) for array as map, O(n) for stl map
        use only mx-min for array size for less memory.
 */


------------------------------------------------------------------------------------------
LC264: Ugly Number-Intution
/*
    Intution:check lc264-1.png
*/


------------------------------------------------------------------------------------------
LC347: Top K Frequent Elements 
/*

Approach1:
    Intuition: can you use a heap(aka priority_queue) to keep track of first k element only, and discard the rest if pq size becomes more than k? | complexity: O(n*log(k))

Approach2:
    Intuition: count occurrance of each character. Then start for loop from x=-10^4 to 10^4. At each palce we increase the totalFoundCount. At place where totalFoundCount become greator than k. that is the desired integer.

    complexity: O(n) or O(x_max-x_min) whichever is greater.

Approach3: using quicksort property that, all element smaller than x goes to left right, and all element greator than x goes to right side.
    implementation: TO-DO: (skipped,as it is above medium)

*/

------------------------------------------------------------------------------------------
LC358: Rearrange String k Distance Apart
 /* 
 Approach1: 
    Intution: try to place maximum char with most frequence at idx i + k
    Trying to place maximum element at index idx, idx+k, idx+2*k will not pass.
    As once the sz is reached, you will take start from next not taken position. and it will result in conflict. Hint try tc: ("abcdabcdabdeac", 4*)
    same tc explained in comment section of https://leetcode.com/problems/rearrange-string-k-distance-apart/discuss/278269/Python-O(N)-solution

Approach2:
    Intution: put all frequency in map. Then use pq and q. pq will give the char with most frequeny count, and q will help extract all character which are already placed. & only send char to pq again when q.size()>=k.
*/


------------------------------------------------------------------------------------------
LC451: Sort Characters By Frequency
/*
    Intution: count character count &then use it in custom stl sorting via custom comperator
*/

------------------------------------------------------------------------------------------
LC692: Top K Frequent Words
/*
Approach1: do custom sorting based on count of words. | O(nlogn), n = count of words
Approach2: count word occurrence, then insert into k-size heap one by one. Discard the overflow element. | O(nlogk)
Approach3: Advance (implementation skipped for now)
    Intution: create a array of trie. where arr[idx] =  trie represention of all words having frequency idx.
    
    Once, the trie[] created, travesal array from arr[N] to arr[1] and add all find words to rans, until k words are found.

    query: how to get all words represented by trie ? Hint:  use pre-order DFS.

    complexity: O(n,counting) + O(n*k1, k2=size of each word=10) + O(n*k2, k2 = time to get all word frong single trie)
            = O(fixed-time)

*/


------------------------------------------------------------------------------------------
LC767: Reorganize String
/*
    Approach1: solve harder version of the problem LC358, then put k =2.
    Approach2: try odd/even placement.
    Approach3: use pq + queue (same as LC258). But this time as k=2, we can just store top of pq instead of storing entire queue.
*/


------------------------------------------------------------------------------------------
LC1439: Find the Kth Smallest Sum of a Matrix With Sorted Rows
/*
Approach1: BruteForce
    one element from row0 can be mapped to 40element of row1, 40element from row2 ...  = 40^40 combinations for array starting with row0 => this will TLE, we cannot generate all possible array
    
    
Approach2:
    Intuition: staring from row[0]. can you iterative generate all the pairs & then filter the best k-pairs for next iteration?

    ref: https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/discuss/609755/C%2B%2BSort-solution-easy-to-understand-with-brief-explanation.

Approach3: 
    Intuition: Similar to LC373. use the function used in that one, and call it for row2 to rown-1.

    ref: https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/discuss/610701/C%2B%2BJavaPython-Binary-Search-O(m*k*log(m*5000))-MinHeap-O(m*k*logk)-Solutions
*/
------------------------------------------------------------------------------------------
