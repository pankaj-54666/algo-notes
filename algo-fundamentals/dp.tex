\chapter{Dynamic Programming}\label{chp:dynamic_programming}

% \lipsum[100]
% \blindtext[10]


The word \textbf{Dynamic} in Dynamic Programming refers that our computation complexity for the given problem can be reduced if:

\begin{enumerate}[(i)]
    \item Current state of the problem depends upon previous state solved.
    \item previous state has been already precomputed \& we have also saved their state.
\end{enumerate}


As we know recursion is way, in which current problem can be expressed in term of smaller sub-problem. Hence, writing the current state of problem in recursive way is the main step in solving question by dynamic programming.

\vspace{5mm}
% \addvspace{10cm}
Steps to Solve Dynamic Programming Question:
\begin{enumerate}[(i)]
    \itemsep0em 
    \item Express the current state of problem in recurrance relation.
    \item solve the problem in recursive way. (by considering all the edge case).
    \item Compute time complexity of recursive solution. Then compute time complexity of memoized solution.
    \item If memoized time complexiy is okay $\Rightarrow$ this is the solution.
    \item If memoized time compleixy is not okay $\Rightarrow$ express solution in alternative recurrance (same as modifying the recursive function defination) way; such that less variable term are mentioned in the recurrance relation.
\end{enumerate}

\section*{Dynamic Programming Questions}
\paragraph{type1} We will list \& discuss some of the common question pattern from this paradigm.

\part{Inclusion-Exclusion}
\input{subset-sub.tex}
\input{coin-change.tex}
\input{rod-cutting.tex}
\part{Ways at idx}
\input{matrix-multiplication.tex}

\part{Subsequence}
\input{lcs.tex}
\input{edit-distance.tex}
\input{lis.tex}
\input{lis2.tex}
\input{lps.tex}

\part{Subarray Problem}
\input{lisa.tex}
\input{lc2771.tex}
\input{lpsa.tex}


\begin{exercise}
    \begin{enumerate}
    \item (LC 1547) Minimum cost to cut a stick.
    \item  For LC1547 print the optimal ordering.
    \item 
    LC 2218 : $f(idx,\_)$ = maximum total value of coing we can pick if we are allowed to pick coins from from arr[0...idx]\\
    now at idx, we have the option to chose either \begin{verbatim} {1}, {1,2}, {1,2,3}... {1,2,...min(k,size)} \end{verbatim} options
       
    we will take the best from all the option.
   
    \item LC 1105: with $f(idx,\_)$ defination as same as 2218.\\
    At idx, we can chose either 1 or 2 or 3 books, ... n books. We will take the best of all.

    \item LC 1547 (simple variation of rod-cutting)
    \item LC 1092- Shortest Common Supersequence
    \item LC801 Minimum Swaps To Make Sequences Increasing 
    \item LC139 Word Break\\ Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
    \item SEPERATOR (Please Categorize)
    \item 
    LC 2218 : $f(idx,\_)$ = maximum total value of coing we can pick if we are allowed to pick coins from from arr[0...idx]\\
    now at idx, we have the option to chose either \begin{verbatim} {1}, {1,2}, {1,2,3}... {1,2,...min(k,size)} \end{verbatim} options
       
    we will take the best from all the option.
   
    \item LC 1105: with $f(idx,\_)$ defination as same as 2218.\\
    At idx, we can chose either 1 or 2 or 3 books, ... n books. We will take the best of all.

    \item LC 1547 (simple variation of rod-cutting)
    \item LC 1092- Shortest Common Supersequence
    \item LC801 Minimum Swaps To Make Sequences Increasing 
    \item LC139 Word Break\\ Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
\end{enumerate}


    { \Large Palindrome Pattern \\}
    In this pattern, range is decided by arr[l..r]. Or arr[0..l] for some case.
    \begin{enumerate}
        \item (LC131) Palindrome Partioning \\Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. 
        \constrain{s.lenght<=16, s[i] \in [a,z]}
        
        \item (LC132) Palindrom Paritioning II \\ For above question, return minimum cuts needed to perform the operation.
        \constrain{s.lenght\leq2000,s\in[a-z]}

        \item (LC1216) Valid Palindrome \\A string is k-palindrome if it can be transformed into a palindrome by removing at most k characters from it. Given a string s and an integer k, return true if s is a k-palindrome.
        \constrain{s.lenght \leq 1000, k \leq s.length, s \in [a-z]}

        \item (LC1246) Palindrome Removal\\ You are given an integer array arr.
        In one move, you can select a palindromic subarray \verb|arr[i], arr[i + 1], ..., arr[j] where i <= j|, and remove that subarray from the given array.
        Return the minimum moves to remove all element from the array.
        \constrain{arr.length \leq 100, arr[i] \in [1,20]}

    \end{enumerate}

\end{exercise}

\begin{exercise}[Extra Pratice]
    \begin{enumerate}
        \item (LC2361) Minimum Costs Using the Train Line
    \end{enumerate}
\end{exercise}

\begin{exerciseHints}[Solutions/Comments:]
    % Comment About Excercise Problem (And possibly have hint too)
    \begin{enumerate}
        \item LC801: Nice problem where state information can be transferred to other variable + if we use base case to detect invalid case, then code can be greatly simplified.
        \item LC139 Word Break \\Give (a) f(idx,\_) solution (b) f(l,r,\_) solution (c) BFS Solution (d) Trie Solution
    \end{enumerate}

    { \Large Palindrome Pattern(almost all dp pattern here) \\}
    \begin{enumerate}
        \item (LC131) Palindrome Partioning \\As the constrain is less, can you backtract all possible combination? Let \verb|f(idx):=| generate the answer when you are given \verb|arr[idx:]| only.
        
        \item (LC132) You can try brute forcing, but now as the constrain reqirement suggest us to use $O(n^2)$ algorithm.
        
        Let \verb|f(l,r):=| minimum cut needed to partion all substring as plaindrome, when you are allowed to use \verb|arr[l..r]| only. Then for each \verb|f(l,r)| you can try cutting at all places and take the best of cost.
        Explain why the complexity is $O(n^2)$ even though we haved used two variable l and r. And we are splittin at all k places also.
        
        If you think your recursive function defination as \verb|f(idx):=| minimum cut need when you are allowed to use \verb|arr[idx:]| only. Then at each idx, you can try to form a substring \verb|s[idx:k]|. If this substring is itself a plaindrome, the problem to \verb|f(k)|.

        There exist other approach, expand around the center. Can you write the code for all 3 above approaches?

        \item (LC1216) Valid Palindrome\\ Try to solve it just like you have solved Edit Distance. Start with l and r pointer, if both equal then no cost to delete. if equal then try deleting left, then right.
        take minimum cost from all three operation.

        LCS way:Alternative approach is to reverse the given string and find maximum subsequence length between the two. The string is k-palindromic if the difference between the string length and subsequence length is not more then k.
        
        \item (LC1246) Palindrome Removal \\Key Observation: A[i] can be deleted either alone or can make a pair. Now in normal \verb|palindrome length| calculation, we make A[l] pair with A[r] (A[r] is first occurrance from right side for arr[l..r]). But, in current case A[i] can me made to pair with all ch which occurr at any index.
        
        \includegraphics[width=\marginparwidth]{./resources/LC1246_p1.jpg}
    \end{enumerate}

    Extra Pratice:
    \begin{enumerate}
        \item (LC2361) Can you deduce the ways at idx? If question were to find total cost to reach end, then you can either use \verb|f(0,_) or f(size-1,_)|. But this time question strongely emphasis to use \verb|f(size-1,_)| as you require \verb|f(1,_), f(2,_)| etc.
        
        In the below figure can you reason as why \verb|A->Change->Move->Change| this move is already embedded on move BA?
        
        \includegraphics[width=\marginparwidth]{resources/LC2361.jpg}
        
    \end{enumerate}
    
\end{exerciseHints}